// Generated by CoffeeScript 1.6.2
"use strict";
/**
 *
 * JJMarkdownEditor 
 * v.0.0.2
 *
 * (2013)
 * 
 * A jQuery Markdown Editor with input & preview area, featuring several extra markdown syntax extensions like [img {id}] and [embed {url}]
 * Requirements: 
 * 	- jQuery
 * 	- Tabby jQuery plugin
 * 	- marked_jjedit.js
 * 	- jquery.jjfileupload.js
 *
*/
(function($) {
  var CustomMarkdownParser, CustomMarkdownParserInterface, JJMarkdownEditor;

  JJMarkdownEditor = (function() {
    /**
    		 * 
    		 * Default options
    		 *
    */

    var setAsActiveDraggable;

    JJMarkdownEditor.prototype.defaults = {
      preview: '#preview',
      parsingDelay: 200,
      dragAndDropAllowed: true,
      hideDropzoneDelay: 1000,
      errorMsg: 'Sorry, but there has been an error.',
      contentGetter: 'val',
      customParsers: {},
      customParserOptions: {},
      afterRender: null,
      onChange: null,
      onBlur: null,
      imageUrl: '/imagery/images/docimage/',
      placeholder: 'PLACEHOLDER',
      charlimit: 0,
      additionalPOSTData: null,
      uploadResponseHandler: null
    };

    function JJMarkdownEditor(selector, opts) {
      var $input;

      $input = null;
      this.$preview = null;
      this.currentDrag = null;
      this.inlineElementDragged = null;
      this.dragCount = 0;
      this.fileDragPermitted = true;
      this.pendingAjax = [];
      this.customParsers = {};
      this.firstTimeRendered = false;
      this.options = $.extend({}, this.defaults, opts);
      this.$input = selector instanceof jQuery ? selector : $(selector);
      this.$input._val = this.$input[this.options.contentGetter];
      this.$preview = this.options.preview instanceof jQuery ? this.options.preview : $(this.options.preview);
      this.initialize();
    }

    /**
    		 *
    		 * Static functions that allow DOM Elements to be dragged into the Preview area of any JJMarkdown Editor
    		 *
    */


    setAsActiveDraggable = function(e) {
      var set;

      if (e.type === 'dragstart') {
        set = $(e.target).data('md-tag');
        if (!set) {
          set = $(e.target).parent().data('md-tag');
        }
        set = set.replace('\\[', '[').replace('\\]', ']');
      } else {
        set = null;
      }
      $.fireGlobalDragEvent(e.type, e.target);
      return JJMarkdownEditor._activeDraggable = set;
    };

    JJMarkdownEditor.setAsDraggable = function($els) {
      if (!JJMarkdownEditor.draggables) {
        JJMarkdownEditor.draggables = [];
      }
      $els = $els.filter('[data-md-tag]');
      if ($els.length) {
        JJMarkdownEditor.draggables.push($els);
        return $els.on('dragstart dragend', setAsActiveDraggable);
      }
    };

    JJMarkdownEditor.cleanupDraggables = function() {
      if (JJMarkdownEditor.draggables) {
        return $.each(JJMarkdownEditor.draggables, function(i, $els) {
          return $els.off('dragstart dragend');
        });
      }
    };

    JJMarkdownEditor.prototype.cleanup = function() {
      this.$input.remove();
      this.$preview.remove();
      if (this.$dropzone) {
        return this.$dropzone.remove();
      }
    };

    JJMarkdownEditor.prototype.initialize = function() {
      var $els, $input, $preview, scrollArea,
        _this = this;

      $.each(this.options.customParsers, function(key, parser) {
        var opts, p;

        p = window[parser];
        if (p) {
          opts = _this.options.customParserOptions[key];
          return _this.customParsers[key] = new p(opts);
        }
      });
      $input = this.$input;
      $preview = this.$preview;
      _this = this;
      $input.tabby().trigger('keyup');
      this.delayTimeout = null;
      $input.off('keyup').on('keyup', function(e) {
        var $this, charlimit, delayTimeout;

        $this = $(this);
        charlimit = _this.options.charlimit;
        if (charlimit > 0 && $input._val().length > charlimit) {
          $input._val($input._val().substring(0, charlimit));
        }
        if (delayTimeout) {
          clearTimeout(delayTimeout);
        }
        return delayTimeout = setTimeout(function() {
          return _this.parseMarkdown();
        }, _this.options.parsingDelay);
      });
      $els = $input.add($preview);
      scrollArea = null;
      $els.on('scroll', function(e) {
        var $partner, $this;

        $this = $(this);
        $partner = $this.is($input) ? $preview : $input;
        if (scrollArea && scrollArea.is($partner)) {
          return false;
        }
        scrollArea = $this;
        $partner[0].scrollTop = this.scrollTop * $partner[0].scrollHeight / this.scrollHeight;
        return setTimeout(function() {
          return scrollArea = null;
        }, 200);
      });
      _this.parseMarkdown();
      if (this.options.dragAndDropAllowed) {
        this.dragAndDropSetup();
      }
      return this;
    };

    JJMarkdownEditor.prototype.parseMarkdown = function() {
      var markdown, raw, seeds,
        _this = this;

      $.each(this.pendingAjax, function(i, pending) {
        if (pending.readyState !== 4 && pending.abort) {
          return pending.abort();
        }
      });
      raw = this.$input._val();
      markdown = marked(raw);
      seeds = [];
      $.each(this.customParsers, function(i, parser) {
        var ids, seed;

        ids = parser.findIDs(raw);
        seed = parser.getData(ids);
        seeds.push(seed);
        if (!parser.noAjax) {
          return _this.pendingAjax.push(seed);
        }
      });
      return $.when.apply($, seeds).then(function() {
        var data;

        _this.pendingAjax = [];
        $.each(_this.customParsers, function(i, parser) {
          return markdown = parser.parseMarkdown(markdown);
        });
        _this.$preview.trigger('markdown:replaced');
        if (raw.length === 0) {
          _this.$preview.html(_this.options.placeholder);
        } else {
          _this.$preview.html(markdown);
        }
        _this.inlineDragAndDropSetup();
        if (_this.options.afterRender) {
          _this.options.afterRender();
        }
        data = {
          raw: raw
        };
        if (_this.customParsers.images) {
          data.images = _this.customParsers.images.returnIds();
        }
        if (_this.options.onChange && _this.firstTimeRendered) {
          _this.options.onChange(data);
        }
        return _this.firstTimeRendered = true;
      });
    };

    JJMarkdownEditor.prototype.dragAndDropSetup = function() {
      var $preview, dropzoneDelay, _bindDropHandler, _setHideDropzoneTimeout,
        _this = this;

      $preview = this.$preview;
      dropzoneDelay = this.options.hideDropzoneDelay;
      $preview.on('dragover', function(e) {
        var $dropzone, $target, $temp, currDrag, func, isContainer;

        if (!_this.currentDrag) {
          _this.currentDrag = {
            $dropzone: $('<div>', {
              'class': 'dropzone'
            })
          };
          _this.dragCount++;
          $preview.data('dragid', _this.dragCount);
          _this.currentDrag.$dropzone.data('dragid', _this.dragCount);
        }
        _bindDropHandler();
        currDrag = _this.currentDrag;
        $dropzone = currDrag.$dropzone;
        if (currDrag.hideDropzoneTimeout) {
          clearTimeout(_this.currentDrag.hideDropzoneTimeout);
        }
        $target = $(e.target);
        if (!$target.is($dropzone)) {
          isContainer = false;
          if ($target.is($preview)) {
            isContainer = true;
          } else {
            if (!$target.attr('data-editor-pos')) {
              $temp = $target.closest('[data-editor-pos]');
              if ($temp.length) {
                $target = $temp;
              } else {
                $target = $preview;
                isContainer = true;
              }
            }
          }
          func = isContainer ? 'appendTo' : 'insertBefore';
          currDrag.$target = $target;
          return $dropzone[func].call($dropzone, $target);
        }
      });
      $preview.on('drop', function(e) {
        var $target;

        $target = $(e.originalEvent.originalTarget);
        if (_this.currentDrag && !$target.is(_this.currentDrag.$dropzone)) {
          _setHideDropzoneTimeout();
          return false;
        }
      });
      _setHideDropzoneTimeout = function() {
        if (!_this.currentDrag) {
          return;
        }
        clearTimeout(_this.currentDrag.hideDropzoneTimeout);
        return _this.currentDrag.hideDropzoneTimeout = setTimeout(function() {
          return _this.currentDrag.$dropzone.hide().detach().show();
        }, dropzoneDelay);
      };
      $preview.on('dragleave', _setHideDropzoneTimeout);
      return _bindDropHandler = function() {
        var $dropzone;

        if (_this.currentDrag.dropHandlerBound) {
          return false;
        }
        _this.currentDrag.dropHandlerBound = true;
        $dropzone = _this.currentDrag.$dropzone;
        $dropzone.on('dragenter', function(e) {
          return $(this).addClass('dragover');
        });
        $dropzone.on('dragleave', function(e) {
          return $(this).removeClass('dragover');
        });
        return $dropzone.on('drop', function(e) {
          var $target, dfdParse, el, hideDropzoneTimeout, md, uploadDfd;

          $target = _this.currentDrag.$target;
          hideDropzoneTimeout = _this.currentDrag.hideDropzoneTimeout;
          if (hideDropzoneTimeout) {
            clearTimeout(hideDropzoneTimeout);
          }
          $dropzone.off('drop');
          _this.currentDrag = null;
          dfdParse = new $.Deferred();
          dfdParse.done(function() {
            $dropzone.remove();
            return _this.parseMarkdown();
          });
          if (el = _this.inlineElementDragged) {
            _this.moveInlineElement($(el), $target);
            _this.inlineElementDragged = null;
            return dfdParse.resolve();
          } else if (md = JJMarkdownEditor._activeDraggable) {
            _this.insertAtEditorPosByEl($target, md + '  \n\n');
            JJMarkdownEditor._activeDraggable = null;
            return dfdParse.resolve();
          } else if (e.dataTransfer.files.length) {
            uploadDfd = JJFileUpload["do"](e, $dropzone, _this.options.imageUrl, _this.options.additionalPOSTData, _this.options.errorMsg, 'image.*');
            return uploadDfd.done(function(data) {
              var nl, obj, rawMd, _i, _len;

              data = $.parseJSON(data);
              if (_this.options.uploadResponseHandler) {
                _this.options.uploadResponseHandler(data);
              }
              rawMd = '';
              for (_i = 0, _len = data.length; _i < _len; _i++) {
                obj = data[_i];
                rawMd += '[img ' + obj.id + ']';
              }
              nl = '  \n\n';
              _this.insertAtEditorPosByEl($target, rawMd + nl);
              return dfdParse.resolve();
            });
          } else {
            return $dropzone.remove();
          }
        });
      };
    };

    JJMarkdownEditor.prototype.inlineDragAndDropSetup = function() {
      var $imgs, $preview,
        _this = this;

      $preview = this.$preview;
      $imgs = $preview.find('[data-md-tag]');
      _this = this;
      $imgs.on('dragstart', function(e) {
        return _this.inlineElementDragged = this;
      });
      $imgs.on('dragend', function(e) {
        return _this.inlineElementDragged = null;
      });
      return $preview.on('markdown:replace', function() {
        return $imgs.off('dragstart dragend');
      });
    };

    JJMarkdownEditor.prototype.moveInlineElement = function($el, $target) {
      var mdNl, mdTag, pos;

      mdTag = $el.data('md-tag').replace(/\\/g, '');
      mdNl = mdTag + '  \n\n';
      pos = $el.data('editor-pos');
      if (!($target.is(this.$preview)) && ($target.data('editor-pos') < pos)) {
        pos += mdNl.length;
      }
      this.insertAtEditorPosByEl($target, mdNl);
      return this.removeAtEditorPos(pos, mdTag);
    };

    JJMarkdownEditor.prototype.removeAtEditorPos = function(pos, md) {
      var mdLength, nl, val;

      val = this.$input._val();
      mdLength = md.length;
      nl = '  \n\n';
      if (val.substring(pos + mdLength, pos + mdLength + nl.length) === nl) {
        mdLength += nl.length;
      }
      val = [val.slice(0, pos), val.slice(pos + mdLength)].join('');
      return this.$input._val(val);
    };

    JJMarkdownEditor.prototype.insertAtEditorPosByEl = function($el, md) {
      var pos, val;

      val = this.$input._val();
      if ($el.is(this.$preview)) {
        val = val + md;
      } else {
        pos = $el.data('editor-pos');
        val = [val.slice(0, pos), md, val.slice(pos)].join('');
      }
      return this.$input._val(val);
    };

    return JJMarkdownEditor;

  })();
  CustomMarkdownParserInterface = {
    findIDs: function(raw) {},
    parseFound: function(found) {},
    getUrl: function(reqIds) {},
    getData: function(ids) {},
    parseMarkdown: function(md) {},
    returnIds: function() {}
  };
  CustomMarkdownParser = (function() {
    CustomMarkdownParser.prototype.url = '';

    function CustomMarkdownParser(opts) {
      var a, b;

      this.cache = [];
      if (opts) {
        for (a in opts) {
          b = opts[a];
          this[a] = b;
        }
      }
    }

    return CustomMarkdownParser;

  })();
  CustomMarkdownParser.prototype.findIDs = function(raw) {
    var cap, found, founds, replacements;

    this._raw = raw;
    replacements = [];
    founds = [];
    while (cap = this.rule.exec(raw)) {
      replacements.push(cap);
      found = this.parseFound(cap[1]);
      if ($.inArray(found, founds) < 0) {
        founds.push(found);
      }
    }
    this._tempReplacements = replacements;
    return founds;
  };
  CustomMarkdownParser.prototype.parseFound = function(found) {
    return found;
  };
  CustomMarkdownParser.prototype.getUrl = function(reqIds) {
    return this.url + '?ids=' + reqIds.join(',');
  };
  CustomMarkdownParser.prototype.getData = function(ids) {
    var dfd, reqIds, resolveData, url,
      _this = this;

    reqIds = [];
    resolveData = [];
    dfd = new $.Deferred();
    $.each(ids, function(i, id) {
      var found;

      found = null;
      $.each(_this.cache, function(j, obj) {
        if (obj.id === id) {
          found = obj;
        }
      });
      if (!found) {
        return reqIds.push(id);
      } else {
        return resolveData.push(found);
      }
    });
    if (!reqIds.length) {
      this.data = resolveData;
      dfd.resolve();
      return dfd;
    }
    url = this.getUrl(reqIds);
    return $.getJSON(url).done(function(data) {
      if ($.isArray(data)) {
        _this.cache = _this.cache.concat(data);
        resolveData = resolveData.concat(data);
        return _this.data = resolveData;
      }
    });
  };
  CustomMarkdownParser.prototype.parseMarkdown = function(md) {
    var insertDataIntoRawTag, patternsUsed, raw, usedIds,
      _this = this;

    insertDataIntoRawTag = function(rawTag, dataName, dataVal) {
      var ltp;

      ltp = rawTag.indexOf('>');
      return [rawTag.slice(0, ltp), ' data-' + dataName + '="' + dataVal + '"', rawTag.slice(ltp)].join('');
    };
    patternsUsed = [];
    raw = this._raw;
    usedIds = [];
    $.each(this._tempReplacements, function(i, replace) {
      var id, obj, pattern, tag;

      obj = null;
      id = _this.parseFound(replace[1]);
      $.each(_this.data, function(j, o) {
        if (o.id === id) {
          obj = o;
        }
      });
      if (obj) {
        usedIds.push(obj.id);
        pattern = replace[0].replace('[', '\\[').replace(']', '\\]');
        tag = insertDataIntoRawTag(obj.tag, 'editor-pos', replace['index']);
        tag = insertDataIntoRawTag(tag, 'md-tag', pattern);
        return md = md.replace(replace[0], tag);
      }
    });
    this._raw = null;
    this._tempReplacements = null;
    this.usedIds = $.unique(usedIds);
    return md;
  };
  CustomMarkdownParser.prototype.returnIds = function() {
    var out;

    out = {
      ids: this.usedIds
    };
    if (this.className) {
      out.className = this.className;
    }
    return out;
  };
  window.JJMarkdownEditor = JJMarkdownEditor;
  return window.CustomMarkdownParser = CustomMarkdownParser;
})(jQuery);
