// Generated by CoffeeScript 1.6.2
"use strict";
var RadialGravity, b2AABB, b2Body, b2BodyDef, b2Fixture, b2FixtureDef, b2PolygonShape, b2Settings, b2Vec, b2World;

b2Vec = Box2D.Common.Math.b2Vec2;

b2BodyDef = Box2D.Dynamics.b2BodyDef;

b2Body = Box2D.Dynamics.b2Body;

b2FixtureDef = Box2D.Dynamics.b2FixtureDef;

b2Fixture = Box2D.Dynamics.b2Fixture;

b2World = Box2D.Dynamics.b2World;

b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

b2AABB = Box2D.Collision.b2AABB;

b2Settings = Box2D.Common.b2Settings;

RadialGravity = (function() {
  RadialGravity.prototype.width = 0;

  RadialGravity.prototype.height = 0;

  RadialGravity.prototype.intervalRate = 0;

  RadialGravity.prototype.adaptive = false;

  RadialGravity.prototype.log = function(value) {
    return self.postMessage({
      key: 'log',
      log: value
    });
  };

  /*
  	 #
  	 # @param int intervalRate
  	 # @param boolean adaptive
  */


  function RadialGravity(intervalRate, adaptive) {
    this.intervalRate = intervalRate;
    this.adaptive = adaptive;
    this.init = function() {
      this.world = new b2World(new b2Vec(0, 0), true);
      this.setBox2DSettings();
      this.hasGravity = false;
      return this.bodyCount = 0;
    };
    this.fixDef = function() {
      var fix;

      fix = new b2FixtureDef;
      fix.density = 0.0;
      fix.friction = 1.0;
      fix.restitution = 0.0;
      fix.shape = new b2PolygonShape;
      return fix;
    };
    this.bodyDef = function(staticBody) {
      var body;

      body = new b2BodyDef;
      if (staticBody) {
        body.type = b2Body.b2_staticBody;
      } else {
        body.type = b2Body.b2_dynamicBody;
        body.allowSleep = true;
      }
      body.fixedRotation = true;
      body.linearDamping = 2.5;
      body.angularDamping = .9;
      body.gravityScale = 0.0;
      return body;
    };
    this.setBox2DSettings = function() {
      b2Settings.b2_linearSleepTolerance = .1;
      b2Settings.b2_angularSleepTolerance = .1;
      return b2Settings.b2_timeToSleep = .5;
    };
    this.init();
  }

  RadialGravity.prototype.borders = {};

  RadialGravity.prototype.borderWidth = 1;

  /*
  	 # set canvas dimensions
  	 #
  	 # @param float width
  	 # @param float height
  */


  RadialGravity.prototype.setDimensions = function(width, height) {
    var border, borderDefs, createBorder, id, updateBorder,
      _this = this;

    this.width = width;
    this.height = height;
    borderDefs = {
      'border-top': {
        x: this.width / 2,
        y: this.borderWidth / -2,
        width: this.width,
        height: this.borderWidth
      },
      'border-right': {
        x: this.width + (this.borderWidth / 2),
        y: this.height / 2,
        width: this.borderWidth,
        height: this.height
      },
      'border-bottom': {
        x: this.width / 2,
        y: this.height + (this.borderWidth / 2),
        width: this.width,
        height: this.borderWidth
      },
      'border-left': {
        x: this.borderWidth / -2,
        y: this.height / 2,
        width: this.borderWidth,
        height: this.height
      }
    };
    createBorder = function(id, border) {
      var body, fix;

      body = _this.bodyDef(true);
      body.userData = id;
      body.position.Set(border.x, border.y);
      fix = _this.fixDef();
      fix.shape.SetAsBox(border.width / 2, border.height / 2);
      _this.world.CreateBody(body).CreateFixture(fix);
      _this.borders[id] = {
        body: body,
        fixture: fix
      };
      return true;
    };
    updateBorder = function(id) {
      var border, data;

      data = _this.borders[id];
      border = borderDefs[id];
      log("update border " + id);
      log(border);
      data.body.position.Set(border.x, border.y);
      return data.fixture.shape.SetAsBox(border.width / 2, border.height / 2);
    };
    log('create borders');
    for (id in borderDefs) {
      border = borderDefs[id];
      if (this.borders[id]) {
        updateBorder(id);
      } else {
        createBorder(id, border);
      }
    }
    this.forceRecalc();
    return true;
  };

  /*
  	 # returns the box2D scale
  	 #
  	 # @return int
  */


  RadialGravity.prototype.scaleFactor = 30;

  RadialGravity.prototype.scale = function() {
    return this.scaleFactor;
  };

  RadialGravity.prototype.setScale = function(val) {
    return this.scaleFactor = val;
  };

  RadialGravity.prototype.ready = function() {
    return this.hasGravity && this.bodyCount > 0;
  };

  RadialGravity.prototype.getState = function() {
    var b, d, distance, gravityDistance, gravityPosition, id, pos, state, vecSum;

    state = {};
    gravityPosition = this.getGravityPosition();
    if (!gravityPosition) {
      return false;
    }
    b = this.world.GetBodyList();
    while (b) {
      id = b.GetUserData();
      if (b.IsAwake() && b.IsActive() && id && id !== 'gravity') {
        pos = b.GetPosition();
        gravityDistance = new b2Vec(0, 0);
        gravityDistance.Add(pos);
        gravityDistance.Subtract(gravityPosition);
        distance = gravityDistance.Length();
        gravityDistance.NegativeSelf();
        vecSum = Math.abs(pos.x + Math.abs(pos.y));
        gravityDistance.Multiply((1000 / vecSum) * 10 / distance);
        d = new b2Vec(gravityDistance.x, gravityDistance.y);
        b.ApplyForce(d, b.GetPosition());
        state[id] = {
          x: pos.x,
          y: pos.y
        };
      } else if (id && id.indexOf('border') !== -1) {
        pos = b.GetPosition();
        state[id] = {
          x: pos.x,
          y: pos.y
        };
      }
      b = b.m_next;
    }
    return state;
  };

  RadialGravity.prototype.update = function() {
    var now, stepRate;

    now = Date.now();
    stepRate = this.adaptive ? now - this.timestamp / 1000 : 1 / this.intervalRate;
    this.world.Step(stepRate, 10, 10);
    this.world.ClearForces();
    return Date.now() - now;
  };

  /*
  	 # creates a gravity box2D-Element
  	 #
  	 # @param gravity GravityCenter
  	 #
  */


  RadialGravity.prototype.gravity = null;

  RadialGravity.prototype.gravityPosition = null;

  RadialGravity.prototype.getGravityPosition = function() {
    var p;

    p = false;
    if (this.gravity) {
      p = this.gravity.GetPosition();
    } else if (this.gravityPosition) {
      p = this.gravityPosition;
    }
    return p;
  };

  RadialGravity.prototype.setGravity = function(gravity) {
    this.gravityPosition = new b2Vec(gravity.x, gravity.y);
    log('gravity position:');
    log(this.gravityPosition);
    this.hasGravity = true;
    return this.forceRecalc();
  };

  RadialGravity.prototype.getGravity = function() {
    var b, id;

    b = this.world.GetBodyList();
    while (b) {
      id = b.GetUserData();
      if (id === 'gravity') {
        return b;
      }
      b = b.m_next;
    }
    return false;
  };

  RadialGravity.prototype.forceRecalc = function() {
    var b, _results;

    b = this.world.GetBodyList();
    _results = [];
    while (b) {
      b.SetAwake(true);
      _results.push(b = b.m_next);
    }
    return _results;
  };

  /*
  	 # creates the bodies and sets the this.ready flag
  	 #
  	 # @param object id: RectangleEntity
  */


  RadialGravity.prototype.setBodies = function(entities) {
    var entity, id, _results;

    _results = [];
    for (id in entities) {
      entity = entities[id];
      _results.push(setBody(id, entity));
    }
    return _results;
  };

  /*
  	 # creates a body
  */


  RadialGravity.prototype.setBody = function(id, entity) {
    var bodyDef, fixDef;

    bodyDef = this.bodyDef();
    if (id === 'gravity') {
      return this.setGravity(entity);
    } else {
      fixDef = this.fixDef();
      fixDef.shape.SetAsBox(entity.width / 2, entity.height / 2);
      bodyDef.position.x = entity.x;
      bodyDef.position.y = entity.y;
      bodyDef.userData = entity.id;
      this.world.CreateBody(bodyDef).CreateFixture(fixDef);
      return this.bodyCount++;
    }
  };

  return RadialGravity;

})();
